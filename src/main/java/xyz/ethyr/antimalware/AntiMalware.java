package xyz.ethyr.antimalware;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Enumeration;
import java.util.List;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.jar.JarEntry;
import java.util.jar.JarFile;
import org.objectweb.asm.ClassReader;
import org.objectweb.asm.tree.ClassNode;
import xyz.ethyr.antimalware.check.Check;
import xyz.ethyr.antimalware.check.impl.DangerousMethodCheck;
import xyz.ethyr.antimalware.check.impl.InvalidAnnotationCheck;
import xyz.ethyr.antimalware.check.impl.InvokeDynamicCheck;
import xyz.ethyr.antimalware.check.impl.OriginalClassHideCheck;
import xyz.ethyr.antimalware.check.impl.ReflectionCheck;
import xyz.ethyr.antimalware.check.impl.StringObfuscationCheck;
import xyz.ethyr.antimalware.check.impl.UnsafeCheck;
import xyz.ethyr.antimalware.helper.ClassHelper;
import xyz.ethyr.antimalware.helper.IOHelper;

public class AntiMalware {

  /*
  Ye boi this class looks like a shit
   */

  private static final AntiMalware INSTANCE = new AntiMalware();

  private static final List<Check> checks = Arrays.asList(
      new DangerousMethodCheck(),
      new OriginalClassHideCheck(),
      new UnsafeCheck(),

      new ReflectionCheck(),

      new InvokeDynamicCheck(),
      new StringObfuscationCheck(),
      new InvalidAnnotationCheck()
  );

  private File path;

  public static AntiMalware getInstance() {
    return INSTANCE;
  }

  public void start(Path path) {
    this.path = path.toFile();

    if (this.path.isFile()) {
      throw new IllegalArgumentException("Path can't be file");
    }

    if (this.path.listFiles() == null) {
      throw new NullPointerException("listFiles");
    }

    for (File file : this.path.listFiles()) {
      if (file.isDirectory() || !file.getName().endsWith(".jar")) {
        continue;
      }

      Plugin plugin = null;
      try {
        //TODO: Recode pls my eyes
        System.out.println(
            "\n#############################################################################################################################################\n");
        System.out.println("Checking: " + file.getAbsoluteFile() + "\n");

        plugin = loadPlugin(file);
        for (Check check : checks) {
          check.check(plugin);
          System.out.println();
        }

        plugin.save();
      } catch (Exception e) {
        e.printStackTrace(); //Pls don't say anything about this
      }

      if (plugin != null) {
        System.out.println(String
            .format("Checked %s, found %s issues", file.getAbsolutePath(), plugin.messages.size()));
      } else {
        System.out.println("Failed to check: " + file.getAbsolutePath());
      }
    }

    System.out.println();
    System.out.println(
        "Obfuscation doesn't mean that plugin contains backdoor just can contain it because it's obfuscated (also people obfuscating plugins to protect from cracking/code stealing/etc)");
    System.out.println(
        "Reflection can be used to hide method invoke but mostly is used to access private method/fields and other shit");
  }

  private Plugin loadPlugin(File file) throws IOException {
    Plugin plugin = new Plugin();

    try (JarFile jarFile = new JarFile(file)) {
      plugin.name = jarFile.getName();

      Enumeration<JarEntry> enumeration = jarFile.entries();
      while (enumeration.hasMoreElements()) {
        JarEntry jarEntry = enumeration.nextElement();
        if (jarEntry.getName().endsWith(".class/")) { //Some exploit check
          plugin.addLog(jarEntry.getName() + " -> Invalid class name (Can be infected)");
        }

        byte[] bytes = IOHelper.readAllBytes(jarFile.getInputStream(jarEntry));
        if (ClassHelper.isClass(jarEntry.getName(), bytes)) {
          try {
            ClassNode classNode = new ClassNode();
            ClassReader classReader = new ClassReader(bytes);
            classReader.accept(classNode, ClassReader.SKIP_FRAMES);

            plugin.classes.put(classNode.name, classNode);
          } catch (Exception e) {
            plugin.addLog(
                jarEntry.getName() + " -> Class crashing asm (Can be infected)"); //ASM Crasher
          }
        }
      }
    }
    return plugin;
  }

  /*
  Bruh
   */
  public static class Plugin {

    private final ConcurrentMap<String, ClassNode> classes = new ConcurrentHashMap<>();
    private final List<String> messages = new ArrayList<>();

    public String name;

    /*
    WTFHUIFUIWAHGUIFWAIFUWGTAFUI
     */
    public void addLog(String message) {
      System.err.println(message);
      if (!messages.contains(message)) {
        messages.add(message);
        messages.add("");
      }
    }

    public void save() throws IOException {
      Files.write(Paths.get(name + ".log"), messages);
    }

    public Collection<ClassNode> getClasses() {
      return classes.values();
    }
  }
}
